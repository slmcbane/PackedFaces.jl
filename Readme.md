PackedFaces.jl
==============
This is a package to represent "faces", or rectangular sub-arrays, that are
packed into a carrier rectangular array. The motivation is postprocessing of data
generated by geophysical models that store the output in a format like this.

The main facility that is user-facing is the `@packed_array` macro. It is used to
create a type representing a packed array of faces; this type derives from an
abstract type that provides a `faces` function to extract the individual faces. Here
is an example: consider the below arrangement of faces:

```
                    ----------
               3:   | 1 | 4  |
                    ----------
                    | 2 | 5  |
                    ----------
                    | 3 | 6  |
                    ----------     4:
    -------------------------- ---------
    | 1 | 3 | 5 | 7 | 9 | 11 | | 1 | 3 |
1:  -------------------------- ---------
    | 2 | 4 | 6 | 8 | 10| 12 | | 2 | 4 |
    -------------------------- ---------
    ---------
    | 1 | 4 |
    ---------
2:  | 2 | 5 |
    ---------
    | 3 | 6 |
    ---------
```

When they are packed in memory, the layout is instead:
```
          1:                  4:          3:             2:
-------------------------- --------- ------------- -------------
| 1 | 3 | 5 | 7 | 9 | 11 | | 1 | 3 | | 3 | 2 | 1 | | 1 | 2 | 3 |
-------------------------- --------- ------------- -------------
| 2 | 4 | 6 | 8 | 10| 12 | | 2 | 4 | | 6 | 5 | 4 | | 4 | 5 | 6 |
----------------------------------------------------------------
```
You can see that in order to fit in the rectangular layout, face 3 was rotated 90° to
the right and face 2 was transposed. The package supports any combination of rotations
and transpositions.

Using this package, generate a type that represents this arrangement of faces
in memory:
```
julia> using PackedFaces

julia> xybounds = (2, 14) # Size in first and second dimension
(2, 14)

julia> facebounds = (
           (1:2, 1:6), (1:2, 12:14), (1:2, 9:11),
           (1:2, 7:8)
       ) # The bounds of the faces, in order, in the packed array.
((1:2, 1:6), (1:2, 12:14), (1:2, 9:11), (1:2, 7:8))

julia> transforms = (
           FaceTransform(), # No transformation
           FaceTransform(transpose=true), # Transposed array
           FaceTransform(rotations=-1), # 90° rotation left
           FaceTransform()
       ) # The transformation that restores each face to its natural orientation
(FaceTransform{0,false}(), FaceTransform{0,true}(), FaceTransform{3,false}(), FaceTransform{0,false}())

julia> interface = ( # Define the interfaces between faces
                     # I *think* this syntax is clear but let me know
           FaceInterface(1 => 2, BOTTOM => TOP, 1:2 => 1:2),
           FaceInterface(1 => 3, TOP => BOTTOM, 5:6 => 1:2),
           FaceInterface(1 => 4, RIGHT => LEFT, 1:2 => 1:2)
       ) # Interfaces aren't used for now but will be for exch routines
(FaceInterface{1 => 2,BOTTOM::FaceCode = 3,(1:2, 1:2)}(), FaceInterface{1 => 3,TOP::FaceCode = 0,(5:6, 1:2)}(), FaceInterface{1 => 4,RIGHT::FaceCode = 1,(1:2, 1:2)}())

julia> # Generate the type definition

julia> @packed_array MyArrayType nfaces=4 xybounds=xybounds facebounds=facebounds transforms=transforms interfaces=interface

julia>
```

The information about the packing is all encoded in the abstract parent type of
`MyArrayType`:
```
MyArrayType |> supertype
PackedFaceArray{T,2,PackingSpec{2,14,4,((1:2, 1:6), (1:2, 12:14), (1:2, 9:11), (1:2, 7:8)),(FaceTransform{0,false}(), FaceTransform{0,true}(), FaceTransform{3,false}(), FaceTransform{0,false}()),(FaceInterface{1 => 2,BOTTOM::FaceCode = 3,(1:2, 1:2)}(), FaceInterface{1 => 3,TOP::FaceCode = 0,(5:6, 1:2)}(), FaceInterface{1 => 4,RIGHT::FaceCode = 1,(1:2, 1:2)}())}()} where T
```
This way the information about how faces are packed is all known at "compile time" for
functions that work on `PackedFaceArray`s.

Now we can create an array given a backing array of the proper size and populate it.
Calling `PackedFaces.faces(A)` returns a tuple of the faces; __importantly__, these are
*not* copies, but *views* onto the parent array. *Modifying the face data modifies the
data in the parent array, following the transformed layout*.

I create an array of `MyArrayType`, and I fill in its faces with their natural
(column-based) indexing; you can see that the indexing is transformed correctly in
the parent array. (Compare to the illustration above).

```
julia> A = MyArrayType(zeros(Int, 2, 14))
2×14 MyArrayType{Int64,Array{Int64,2}}:
 0  0  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0  0

julia> faces = PackedFaces.faces(A)
([0 0 … 0 0; 0 0 … 0 0], [0 0; 0 0; 0 0], [0 0; 0 0; 0 0], [0 0; 0 0])

julia> faces[1]
2×6 view(::Array{Int64,2}, 1:2, 1:6) with eltype Int64:
 0  0  0  0  0  0
 0  0  0  0  0  0

julia> faces[1] .= [1 3 5 7 9 11
       2 4 6 8 10 12]
2×6 view(::Array{Int64,2}, 1:2, 1:6) with eltype Int64:
 1  3  5  7   9  11
 2  4  6  8  10  12

julia> faces[2]
3×2 PermutedDimsArray(view(::Array{Int64,2}, 1:2, 12:14), (2, 1)) with eltype Int64:
 0  0
 0  0
 0  0

julia> faces[2] .= [1 4
       2 5
       3 6]
3×2 PermutedDimsArray(view(::Array{Int64,2}, 1:2, 12:14), (2, 1)) with eltype Int64:
 1  4
 2  5
 3  6

julia> faces[3]
3×2 PermutedDimsArray(::MirroredArrays.MirroredArray{2,2,Int64,SubArray{Int64,2,Array{Int64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}, (2, 1)) with eltype Int64:
 0  0
 0  0
 0  0

julia> for i ∈ 1:6
       faces[3][i] = i
       end

julia> faces[3]
3×2 PermutedDimsArray(::MirroredArrays.MirroredArray{2,2,Int64,SubArray{Int64,2,Array{Int64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}, (2, 1)) with eltype Int64:
 1  4
 2  5
 3  6

julia> faces[4]
2×2 view(::Array{Int64,2}, 1:2, 7:8) with eltype Int64:
  0  0
  0  0

julia> faces[4] .= [1 3
       2 4]
2×2 view(::Array{Int64,2}, 1:2, 7:8) with eltype Int64:
 1  3
 2  4

julia> A
2×14 MyArrayType{Int64,Array{Int64,2}}:
   1  3  5  7   9  11  1  3  3  2  1  1  2  3
   2  4  6  8  10  12  2  4  6  5  4  4  5  6
```

I will be adding more documentation and tests to this package soon (™).
